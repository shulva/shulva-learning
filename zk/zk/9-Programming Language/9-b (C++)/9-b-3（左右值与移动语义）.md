# 左右值与移动语义

> [!quote]
> https://en.cppreference.com/w/cpp/language/reference
> https://en.cppreference.com/w/cpp/language/move_constructor

### 左右值

**左值 (Lvalue - Locator value)**：可以放在赋值操作符 = **左边**的表达式。它代表一个**有名字、有固定内存地址**的对象，可以被反复使用。

```cpp
int x = 10;       // x 是一个左值
std::string s = "hello"; // s 是一个左值
int* p = &x;      // *p 是一个左值
```

**右值 (Rvalue - Read value)**：只能放在赋值操作符 = **右边**的表达式。它通常代表一个**临时的、没有名字**的值，一般来说语句结束后就会被销毁。

```cpp
int y = 10;           // 10 是一个右值
int z = x + y;        // (x + y) 的计算结果是一个右值
std::string str = "world"; // "world" 是一个右值
std::string getName() { return "Bjarne"; }
std::string name = getName(); // getName() 的返回值是一个右值
```

这个区分告诉编译器一个对象的“生命周期”和“身份”。
左值是“居民”，长期存在。右值是“过客”，转瞬即逝。

> [!question] 拷贝开销问题
> 假设我们有一个管理动态内存的类，比如一个简单的字符串类：
> ```cpp
> class MyString{
>  MyString(const char* s) = default;
>  MyString(const MyString& other) = default; //深拷贝
>  ~MyString() = default;
>
>  // 返回一个临时对象 (右值)
>  MyString createString() { return MyString("temp string");}
>
> }
>
> int main(){
> MyString s1 = createString(); }
> }
>
>
> ```
> 分析一下流程：
> 1. createString() 函数内部，调用**构造函数**创建了一个临时的 MyString 对象。它在内部申请了一块内存，并存入了 "temp string"。
>2. createString() 函数返回这个临时对象。
>3. 为了用这个临时对象初始化 s1，编译器调用了**拷贝构造函数** MyString(const MyString& other)。
>4. 在拷贝构造函数中：
    >- **又一次**申请了新的内存。
    >- 把临时对象中的数据 "temp string" **拷贝**到这块新内存里。
>5. createString() 返回的那个临时对象生命周期结束，调用其**析构函数**，释放了它持有的内存（第一块内存）。
>6. main 函数结束，s1 被销毁，调用其**析构函数**，释放了它持有的内存（第二块内存）。
>
>我们只是想把临时对象里的资源（存着 "temp string" 的内存）**转移**给 s1 就行了
>结果却做了一次昂贵的“分配新内存 + 拷贝数据”的深拷贝操作，然后马上又把原来的内存释放掉了，无形中降低了性能。


### 移动语义

移动语义是C++11及以后版本性能提升的关键特性之一，它使得像 std::vector, std::string, std::unique_ptr 等资源管理类能够被高效地按值返回和传递。

C++11为了解决类似于拷贝开销的问题，引入了两个新东西：

1. **右值引用 (Rvalue Reference)**：用 && 表示，它**只能绑定到右值**。这让我们可以专门为右值（临时对象）编写特定版本的函数。
    
2. **移动构造函数 (Move Constructor)** 和 **移动赋值运算符 (Move Assignment Operator)**。

如果使用移动构造函数来移动资源，则有:

 ```cpp
 class MyString{
  // ... 其他函数保持不变 ... 

  // 移动构造函数 
  MyString(MyString&& other) { 
  // 参数是右值引用 
  
  // 1. 移动走 other 的资源，移动的不是对象[^1]
  this->data = other.data;  
  this->size = other.size; 
  
  other.data = nullptr; //移交所有权，避免对一个资源在析构中释放两次
  other.size = 0; 
  }

 ```

**新的执行流程：**

1. createString() 函数内部，调用**构造函数**创建了一个临时的 MyString 对象。
    
2. createString() 函数返回这个临时对象。这是一个**右值**。
    
3. 编译器发现，要用一个右值来初始化 s1，并且现在有一个专门处理右值的**移动构造函数** MyString(MyString&&)。
    
4. 编译器**选择调用移动构造函数**：
    
    - s1 直接“移动”走了临时对象的 data 指针（没有分配新内存，没有拷贝数据，只是几个指针的赋值操作）。
        
    - 临时对象的 data 指针被设置为 nullptr。
        
5. 临时对象生命周期结束，调用其**析构函数**。因为它内部的指针是 nullptr，delete[] nullptr 是安全无害的。
    
6. main 函数结束，s1 被销毁，释放它移动来的内存。

- **旧方法（拷贝）**：分配内存 + 拷贝数据 + 释放内存，开销很大。
- **新方法（移动）**：几个指针的赋值。资源所有权转移无疑提高了性能。


> [!question] std::move
> 有时候，我们有一个左值，但我们确定不再需要它了，想把它当成右值来触发移动语义。这时就需要 std::move
> ```
> MyString a("hello");
>
> // 强制把 a 当成右值，调用移动构造函数
> //a 的资源已经被 b 移走，a 内部的指针是 nullptr，之后不能再使用a。
> MyString b = std::move(a);
> ```
>std::move 本身不做任何移动操作，它只是一个**类型转换**，它告诉编译器：“请把这个左值当作右值来处理吧”。

[^1]: https://github.com/shulva/mcpp-standard/blob/dev/dslings/cpp11/05-move-semantics-2.cpp
