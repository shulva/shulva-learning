# Special Member Function

> [!quote]
> - https://en.cppreference.com/w/cpp/language/function#Function_definition
 >- https://en.cppreference.com/w/cpp/language/function#Deleted_functions

## Overview

> A constructor is called every time a new instance of the class is created 
> And the destructor is called when it goes out of scope

![2025Fall-13-SpecialMemberFunctions, 页面 15](files/slides/CS106L/2025Fall-13-SpecialMemberFunctions.pdf#page=15)

> 拷贝构造函数与拷贝赋值运算符的对比

![2025Fall-13-SpecialMemberFunctions, 页面 22](files/slides/CS106L/2025Fall-13-SpecialMemberFunctions.pdf#page=22)

> We don't have to write out any of these! They all have default versions that are generated automatically!

```cpp
class Widget {
public:
    Widget();                                   // default constructor:
												// ✅ Takes no parameters and creates a new object
												
    Widget(const Widget& w);                    // copy constructor
												// ✅ Creates a new object as a member-wise copy of another
												
    Widget& operator = (const Widget& w);       // copy assignment operator
    											// ✅ Assigns an already existing object to another
    											
    ~Widget();                                  // destructor
	    										// ✅ Called when the object goes out of scope	
	    										
    Widget(Widget&& rhs);                       // move constructor
    Widget& operator = (Widget&& rhs);          // move assignment operator
    												
}
```

![2025Fall-13-SpecialMemberFunctions, 页面 53](files/slides/CS106L/2025Fall-13-SpecialMemberFunctions.pdf#page=53)
## Copy and copy assignment

When we create a constructor, we need to initialize all of our member variables.
However, initializing them to be the default value and then reassigning is inefficient!

There are two steps happening here:
- the first is that `_size, _capacity, and _data` may have been default initialized
- Then the assignment to the variables, which effectively doubles the work.

事实上，我们可以使用Member initialization Lists:[成员初始化列表](9-b-6%20（初始化与构造函数）.md#^list-construct)来提高效率
成员初始化列表如何提高效率，以及何种情况下必须使用成员初始化列表，链接中描述的很详细

```cpp
template <typename T> 
Vector<T>::Vector() 
{
	_size = 0;
	_capacity = 4;
	_data = new T[_capacity];
}
```

> 有一些拷贝的情况，我们是必须override默认的SMF的

This is problematic because anything done to one pointer affects the other!
![2025Fall-13-SpecialMemberFunctions, 页面 38](files/slides/CS106L/2025Fall-13-SpecialMemberFunctions.pdf#page=38)

- Many times, you will want to create a copy that does more than just copies the member variables. 
- **Deep copy**: an object that is a complete, independent copy of the original. 
- In these cases, you'd want to **override the default special member functions** with your own implementation! 
- Declare them in the header and write their implementation in the .cpp, like any function!

![2025Fall-13-SpecialMemberFunctions, 页面 41](files/slides/CS106L/2025Fall-13-SpecialMemberFunctions.pdf#page=41)


## delete

> How do you prevent copies in special circumstance?

Setting a special member function to **delete** removes its functionality!
Now copying isn't a possible operation.

```cpp
class PasswordManager {
public:
    PasswordManager();
    PasswordManager(const PasswordManager& pm);
    ~PasswordManager();
    // other methods ... 
    PasswordManager(const PasswordManager& rhs) = delete;
    PasswordManager& operator = (const PasswordManager& rhs) = delete;
    
private:
    // other important members ...
}
```

This is how classes like `std::unique_ptr` work!
![2025Fall-13-SpecialMemberFunctions, 页面 47](files/slides/CS106L/2025Fall-13-SpecialMemberFunctions.pdf#page=47)

## Rule of Zero and Rule of Three and Rule of Five

> If a class doesn't manage memory (or another external resource), the compiler generated versions of the SMFs are sufficient!

If the default SMFs work, don't define your own! 
We should only define new ones when the default ones generated by the compiler won't work. 
This usually happens when we work with **dynamically allocated memory**, like pointers to things on the heap!

![2025Fall-15-OptionalAndTypeSafety, 页面 8](files/slides/CS106L/2025Fall-15-OptionalAndTypeSafety.pdf#page=8)

> 当然，Rule of Three 别忘了也定义destructor，毕竟你要手动管理资源

![2025Fall-14-MoveSemantics, 页面 85](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=85)


![2025Fall-14-MoveSemantics, 页面 85](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=86)

## Pop Quiz

```cpp
vector<int> func(vector<int> vec0) {
    vector<int> vec1;   // Default Constructor
    vector<int> vec2(3);// Custom constructor, not SMF
    vector<int> vec3{3};// Uniform initialization, not an SMF
    vector<int> vec4(); // Tricky, this is a function definition
    vector<int> vec5(vec2); // Copy Constructor
    vector<int> vec6{}; // Initializer list is empty – empty vector via list initialization
    vector<int> vec7{static_cast<int>(vec2.size() + vec6.size())}; // List initialization
    vector<int> vec8 = vec2;// Copy constructor
    vec8 = vec2; // Copy assignment operator
    return vec8;
}
```

3,6,7都是列表初始化