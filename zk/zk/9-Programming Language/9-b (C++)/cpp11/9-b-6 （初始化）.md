# 初始化

> [!quote]
> https://en.cppreference.com/w/cpp/language/list_initialization.html
> https://en.cppreference.com/w/cpp/utility/initializer_list.html
> https://en.cppreference.com/w/cpp/language/initializer_list.html#Delegating_constructor

### 列表初始化

在 C++11 之前，初始化变量的语法非常混乱：
```cpp
int x = 5; // C-style initialization 
int y(5);  // Constructor-style initialization 
char name[] = "cat"; // For C-style arrays 
std::vector<int> v; 
v.push_back(1); 
v.push_back(2); 
v.push_back(3);
```

C++11 引入了**列表初始化**（也常被称为**统一初始化**或**花括号初始化**），旨在提供一种适用于所有场景的、更安全、更直观的初始化语法。

```cpp
// C++11 and later 
int x {5}; // Direct list initialization 
int y = {5}; // Copy list initialization 
std::string name {"hello"}; 
std::vector<int> v {1, 2, 3};
MyClass obj {10, "world"}; // Works for user-defined classes
```

列表初始化可以用来解决窄化转换和声明歧义问题。

```cpp
//浮点转整数
double pi = 3.14159;
int a = pi; // 合法。a 的值变为 3，小数部分被截断。信息丢失

//范围较大的类型转为范围较小的类型
int large_number = 1000;
char c = large_number;// 合法。但 1000 远超 char 的表示范围。 
// c 的值会因溢出而变成一个不可预期的值 (比如 -24)。 
// 这是非常危险的 bug 源头

//从整数类型转换为浮点类型（可能丢失精度），少见

long long big_int = 9007199254740993; // 2^53 + 1 
double d = big_int; // d 的值可能变成 9007199254740992.0，因为 double 的精度有限

```

C++11 的列表初始化 {} 在编译阶段就将这些危险的转换视为**错误**。

```cpp
double pi = 3.14159; 
int a {pi}; // COMPILE ERROR!

如果想要声明a，你必须显式地进行类型转换，这表明你已经意识到了可能的数据丢失：

int a {static_cast<int>(pi)}; // OK. 程序员明确表示要截断小数。
```

这使得 {} 成为一种更安全、更健壮的初始化方式，是现代 C++ 编程中应该优先选择的语法。

通过强制你显式地使用 `static_cast` 来处理这些转换，C++ 强迫程序员思考行为的后果。这大大提高了代码的质量和可维护性。


> [!question] 声明歧义 Most Vexing Parse
> 假设你有一个简单的类 MyTimer，它有一个默认构造函数（即不带参数的构造函数）。
> 
> ```cpp
> class MyTimer { 
> 	public: MyTimer() { /* ... */ } // Default constructor
> 	void start() { /* ... */ } 
> };
> 
> int main() 
> { 
> 	MyTimer timer(); // <--- 问题就在这里！ 
> 	timer.start(); // <--- COMPILE ERROR! 
> }
> ```
> 
> **程序员的意图是**：定义一个名为 timer 的变量，其类型为 MyTimer，并调用默认构造函数 MyTimer() 来初始化它。
> 
> **但编译器的解释是**：你声明了一个名为 timer 的**函数**，该函数不接受任何参数，并且返回一个 MyTimer 类型的对象。
> 
> 所以，当你试图调用 timer.start() 时，编译器会报错，错误信息通常会是类似这样的：
> `error: request for member 'start' in 'timer', which is of non-class type 'MyTimer()'`
> 这里的 MyTimer() 类型正是在告诉你，编译器认为 timer 是一个函数。
> 
> 这背后的根本原因是 C++ 的一条核心解析规则：
> **“如果一段代码可以被解析成一个有效的声明，那么编译器就必须把它当作声明来处理。”**
> 
> 我们来分析 `MyTimer timer();`这行代码：
> 
> **它可以被看作是变量定义吗？** 是的，类型名 变量名(构造函数参数) 是一种初始化形式。
> **它可以被看作是函数声明吗？** 是的，返回类型 函数名(参数列表) 是标准的函数声明语法。
> 
> 由于它同时满足两种可能性，并且其中一种是函数声明，所以根据规则，它**必须被解析为函数声明**。
> 
> ```cpp
> // 更加隐蔽的例子
> // 你的意图：创建一个临时的、默认构造的 MyTimer 对象， 
> // 然后用这个临时对象来初始化 t。
> MyTimer t(MyTimer());
> 
> // 编译器的解释：声明一个函数 t，它接受一个参数。 
> // 这个参数是一个“指向不接受参数、返回 MyTimer 对象的函数的指针”。 // 完全符合 C++ 语法！
> ```
> 
> 使用列表初始化就能避免这种歧义：
> ```cpp
> int main() 
> { 
> 	// 错误的、有歧义的方式 (Most Vexing Parse) 
> 	MyTimer timer(); 
> 	
> 	// 正确的、无歧义的方式 (C++03 传统方式) 
> 	MyTimer timer; // 不加括号，总是调用默认构造函数 
> 	
> 	// 正确的、无歧义的方式 (C++11 推荐方式) 
> 	MyTimer timer{}; // 使用列表初始化，清晰地表示对象定义 
> 	
> 	timer.start(); // 现在 timer 是一个对象了 
> }
> ```

####  `std::initializer_list<T>`

**std::initializer_list 是让列表初始化能够作用于class类型的关键机制。**

这个关系的核心规则是**构造函数重载决议**：

当使用列表初始化 `T obj {v1, v2, ...};` 来创建一个类的对象时，编译器会**优先**寻找并匹配一个接受 `std::initializer_list` 作为参数的构造函数。

如果类 T 定义了这样的构造函数，那么 `{v1, v2, ...}` 就会被自动包装成一个 `std::initializer_list` 并传递给这个构造函数。

```cpp
class vector { 
	public:  
    int mSize;
    int *data;
    
	// THE MAGIC CONSTRUCTOR: 
	vector(std::initializer_list<int> init){
		mSize = list.size();
        data = new int[mSize];
        int i = 0;
        for (const auto& val : list) {
            data[i++] = val;
        }	 
	}
	// ... other methods ... 
};

//...
std::vector<int> v {1, 2, 3};
```

### 委托构造函数

**委托构造函数允许一个构造函数调用同一个类中的另一个构造函数来完成部分或全部的初始化工作。**

这样，你就可以把共同的初始化逻辑集中在一个构造函数中，其他构造函数只需“委托”给它即可，从而避免了代码重复。

在 C++11 之前，如果你有一个类，它有多个构造函数，并且这些构造函数之间有很多共同的初始化逻辑，你通常会遇到代码重复的问题。

```cpp
    Account(std::string id_) {
        id = id_;
        name = "momo";
        coin = "0 元";
    }

    Account(std::string id_, std::string name_) {
        id = id_;
        name = name_;
        coin = "0 元";
    }

    Account(std::string id_, std::string name_, int coin_) {
        id = id_;
        name = name_;
        coin = std::to_string(coin_) + "0元";
    }
```

当然，你也可以将相同的逻辑抽出到一个init()函数中再在各个构造函数中调用，但是这样做可维护性不好，而且对于const 成员不友好（const 成员必须在**成员初始化列表**中初始化，而不能在构造函数体中赋值）。

C++11 引入了一种新的语法，允许一个构造函数直接调用另一个构造函数。这个被调用的构造函数被称为**目标构造函数 (target constructor)**，调用它的构造函数被称为**委托构造函数 (delegating constructor)**。

在委托构造函数的**成员初始化列表**位置，调用目标构造函数即可。

```cpp
    Account(std::string id_): Account(id_, "momo")
    {
    }

    Account(std::string id_, std::string name_):Account(id_, name_, 0) 
    {
    }

    Account(std::string id_, std::string name_, int coin_) {
        id = id_;
        name = name_;
        coin = std::to_string(coin_) + "元";
        obj = Object(name_);
    }
```



> [!warning] 委托构造函数注意事项
> 1. **委托发生在成员初始化列表**：你不能在构造函数的函数体内部调用另一个构造函数。委托调用是构造过程的第一步。
> 2. **不能同时委托和初始化成员**：如果一个构造函数委托给另一个构造函数，它的成员初始化列表**不能再包含任何成员的初始化**。因为所有的初始化工作都由目标构造函数负责了。
> ```cpp
> class MyClass 
> { 
> 	int x, y; 
> 	public: MyClass(int val) : x(val), y(0) {} //ok
> 	
> 	MyClass() : MyClass(0), y(1) {} 
> 	// ERROR: Cannot delegate and initialize 'y' at the same time. 
> };
> 
> ```
> 3. **可以形成委托链**：A() 委托给 B(int)，B(int) 委托给 C(int, int) 是可以的。但要小心，**不要形成循环委托**（A 委托给 B，B 又委托给 A），这会导致编译错误。


> [!NOTE] 成员初始化列表
> **成员初始化列表**是 C++ 构造函数特有的一种语法，它位于构造函数参数列表的右括号之后、函数体的左花括号之前，并以一个冒号 : 开始。
> 
> 它的唯一目的，就是在对象创建时，**直接初始化**（而不是赋值）类的成员变量。
> 
> ```cpp
> ClassName(type1 arg1, type2 arg2) : member1(arg1), member2(value), member3(arg2) // <-- 这就是成员初始化列表
> {
>     // 这里是构造函数的函数体
>     // ...
> }
> ```
> 
> 成员初始化列表和在构造函数体内赋值有什么区别？
> ```cpp
> class Person 
> { 
> 	std::string m_name; 
> 	public: 
> 	
> 	Person(const std::string& name) : m_name(name)   
> 	// <-- 初始化 (Initialization) 
> 	{ } 
> 
> 	Person(const std::string& name) 
> 	{ 
> 		// 构造函数体 
> 		m_name = name; // <-- 赋值 (Assignment) 
> 	}
> };
> ```
> 
> 在为Person对象分配内存后，第一种成员初始化列表的方式在 `m_name` 的内存位置上，直接调用 `std::string` 的拷贝构造函数 `std::string(name)`，**一次性创建并初始化** `m_name`,之后进入空的构造函数体。
> 
> 第二种方法则会由于 `m_name` 没有出现在初始化列表中，系统会**自动调用 `std::string` 的默认构造函数**来初始化 `m_name`（创建一个空的 `std::string`）。之后在构造函数中调用 `std::string 的**赋值运算符 (operator=)`**，将 `name` 的内容拷贝到已经存在的 `m_name` 对象中。这会丢弃 `m_name` 之前（空字符串）的内容。
> 
> 相比于第一种方法，这是两步的过程：**默认初始化 -> 赋值**。这不仅效率更低（多了一次无意义的默认构造和一次赋值操作），而且在**某些情况下**是完全行不通的。
> 
> 在以下三种情况下，你**必须**使用成员初始化列表，因为这些类型的成员无法在构造函数体内被“赋值”。
> 
> ```cpp
> class MyClass 
> { 
> 	1. const成员变量的值在对象创建时就必须被确定，并且之后不能再被修改。赋值操作const_var=value本质上是一种对const的修改，所以是非法的。
> 	
> 	private: 
> 	const int m_id;//1.const
> 	int& m_ref;//2.引用
> 	Another_Object another;//3.无默认构造函数的对象
> 	
> 	public: MyClass(int id) : m_id(id) 
> 	// 正确：必须在这里初始化 const 成员 
> 	{  
> 		m_id = id; // 错误！不能给 const 成员赋值
> 	} 
> 
> 	2.引用（&）必须在声明时就绑定到一个对象，且之后不能再改变其引用的对象。因此，引用成员也必须在初始化列表中进行初始化。
> 	MyClass(int& some_var) : m_ref(some_var)  
> 	{ 
> 		 m_ref = some_var; // 错误！引用不能被重新赋值 
> 	}
> 
> 	3.如果一个成员变量是另一个类的对象，而那个类没有默认构造函数，那么编译器就不知道如何在进入构造函数体之前自动初始化它。你必须在初始化列表中明确告诉编译器使用哪个构造函数。
> 
> 	Myclass():m_another_object(val){
> 		// 如果没有上面的初始化列表，编译器会尝试调用默认构造函数
> 		// 但它不存在，所以会导致编译错误！
> 	}
> };
> ```
> 
> 优先使用成员初始化列表来初始化所有成员变量是良好的习惯。