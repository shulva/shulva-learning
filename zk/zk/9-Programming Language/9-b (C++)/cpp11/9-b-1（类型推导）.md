# 类型推导

> [!quote]
> - https://en.cppreference.com/w/cpp/language/auto
> - https://en.cppreference.com/w/cpp/language/decltype


![2025Fall-02-TypesAndStructs, 页面 18](files/slides/CS106L/2025Fall-02-TypesAndStructs.pdf#page=95)

> [!NOTE] 尾返回类型
> 在 C++11 及以后版本中，当函数的返回类型依赖于参数类型时（如模板函数），传统的 “返回类型在前” 的语法无法直接使用，因为参数此时尚未声明。此时需用`->`将返回类型后置
>
>**这样可以先声明参数，再通过参数表达式推导返回类型，从而确保编译时类型推导的合法性**。
>```cpp
> // 传统语法：无法直接推导a + b的类型（a和b在add_func前还未声明）
> decltype(a + b) add_func(int a, double b);  // 错误，a和b未定义
>
> // 尾返回类型语法：正确推导返回类型
> auto add_func(int a, double b) -> decltype(a + b);
>
>```
> `-> decltype(表达式)` 可动态推导返回类型，避免硬编码函数返回类型，无需思考返回值类型
>
>```cpp
>auto add_func(int a, double b) -> decltype(a + b) 
>{ return a + b;} // 返回类型为int+double的结果类型double 
>```
>
> 在模板函数中，参数类型未知，尾返回类型是推导返回类型的唯一方式
>
>```cpp
>template <typename T, typename U>
>auto template_add(T a, U b) -> decltype(a + b) 
> { return a + b;}
>```
>
> C++14 引入`decltype(auto)`后，尾返回类型可简化为前置声明
>
>```cpp
>template <typename T, typename U>
> decltype(auto) template_add(T a, U b) 
> { return a + b;}
>```


> [!NOTE] decltype 推导规则[^1]
>
> 1. **`decltype(表达式)`**：
>  
>    - 若表达式是**左值**（如变量、成员访问表达式），推导为**类型 &**；
>    - 若表达式是**右值**（如字面量、临时值），推导为**类型**。
>2. **`decltype((表达式))`**：
>    
>    - 无论表达式是否为左值，**加括号后视为左值表达式**，推导为**类型 &**（除非表达式本身是右值引用）。
>

[^1]: https://github.com/shulva/mcpp-standard/blob/main/dslings/cpp11/00-auto-and-decltype-4.cpp
