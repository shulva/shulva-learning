# using


> [!quote]
> https://en.cppreference.com/w/cpp/language/type_alias.html

**为什么引入?**

- 替代传统的`typedef`语法，提供更直观的类型别名定义方式
- 支持模板别名，增强泛型编程的表达能力
- 提高代码可读性，特别是对于复杂类型
- 与`using`声明语法保持一致

注: `using`关键字在C++11之前就已经存在, 但当时主要是作为命名空间和类成员声明来使用的
- 声明命名空间: `using namespace std;`
- 类成员声明: `struct B : A { using A::member; };`

**类型别名和typedef有什么区别?**

- 语法更直观：`using NewType = OldType` vs `typedef OldType NewType`
- 支持模板别名，而`typedef`不支持
- 在模板编程中更加灵活和强大


![2025Fall-02-TypesAndStructs, 页面 18](files/slides/CS106L/2025Fall-02-TypesAndStructs.pdf#page=92)

![Streams 2, 页面 80](files/slides/CS106L/Streams%202.pdf#page=80)

### 基础用法

##### 基本类型别名

```cpp
typedef int Integer; // 传统typedef方式
using Integer = int; // C++11 using方式

// 使用别名
Integer i = 1;
int j = 2;
```

##### 复杂类型别名

为复杂类型（如函数指针、嵌套类型）创建别名

```cpp
// 函数指针别名
using FuncPtr = void(*)(int, int);
using StringVector = std::vector<std::string>;

// 嵌套类型别名
struct Container {
    using ValueType = int;
    using Iterator = std::vector<ValueType>::iterator;
};

void example(int a, int b) {
    // 函数实现
}

int main() {
    FuncPtr func = example; // 等价: void(*func)(int, int) = example;
    StringVector strings = {"hello", "world"}; // 等价: std::vector<std::string> strings...
    Container::ValueType value = 100; // 等价: int value = 100;
    return 0;
}
```

##### 别名模板
为模板类型创建别名，增强泛型编程能力

```cpp
// 别名模板
template <typename T>
using Vec = std::vector<T>;

// 基于泛型, 创建其"子集合"别名类型
template <typename T>
using Vec3 = std:Array<T, 3>;
template <typename T>
using Vec4 = std:Array<T, 4>;

// 带默认参数的别名模板
template <typename T, typename Compare = std::less<T>>
using Heap = std::priority_queue<T, std::vector<T>, Compare>;//比较器也能指定

int main() {
    Vec<int> numbers = {1, 2, 3};
    Vec3<float> v3 = {1.0f, 2.0f, 3.0f};
    Vec4<float> v4 = {1.0f, 2.0f, 3.0f, 4.0f};
    Heap<int> minHeap;
    Heap<int, std::greater<int>> maxHeap;
    return 0;
}
```

### 注意事项

##### 模板别名的作用域

别名模板必须在类作用域或命名空间作用域中声明,定义不能直接放在 main 函数（或任何其他函数体内部）中。

在 C++ 中，类模板、函数模板、以及这里使用的 类型别名模板的定义都必须在**命名空间范围 (namespace scope)** 或**类范围 (class scope)** 内进行。它们定义新的类型或工厂，而不是**运行时执行的代码**。毕竟，模板是编译时技术。

```cpp
namespace MyNamespace {
    template<typename T>
    using MyVector = std::vector<T>;
}

class MyClass {
public:
    template<typename T>
    using Ptr = T*;
};

// 错误：不能在函数作用域中声明别名模板
// void func() {
//     template<typename T>
//     using LocalAlias = T;  // 编译错误
// }
```

##### 递归别名限制

别名模板不能直接或间接引用自身

```cpp
template<typename T>
struct A;

// 错误：递归别名
// template<typename T>
// using B = typename A<T>::U;

template<typename T>
struct A {
    // typedef B<T> U;  // 这会导致递归定义错误
};
```