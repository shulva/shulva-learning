# 左右值与移动语义

> [!quote]
> https://en.cppreference.com/w/cpp/language/reference
> https://en.cppreference.com/w/cpp/language/move_constructor

## Overview

![Streams 2, 页面 93](files/slides/CS106L/Streams%202.pdf#page=93)

![2025Fall-14-MoveSemantics, 页面 4](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=4)

## The Problem

![2025Fall-14-MoveSemantics, 页面 21](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=21)

> Key Idea: The return value of a function is temporary (it's destroyed before the next line)

`Photo selfie = takePhoto();` 
The compiler is going to clean this object(`takePhoto()`) up before moving onto the next line!


![2025Fall-14-MoveSemantics, 页面 22](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=22)

> [!NOTE] RVO (Return Value Optimization，返回值优化)
> 简单来说，它的作用是：**消除函数返回对象时产生的不必要的拷贝（Copy）或移动（Move）操作。**
> #####  没有 RVO 时发生了什么？
> 
> 假设没有 RVO，代码 `Photo selfie = takePhoto();` 的执行过程非常繁琐：
>  **函数内部**：`takePhoto()` 函数里创建了一个临时的 `Photo` 对象（比如叫 `temp_A`）。
>  **返回时**：为了把结果传出来，编译器把 `temp_A` **拷贝**（或移动）到一个临时存储区（`temp_B`）。
>  **赋值时**：把 `temp_B` **拷贝**（或移动）给你的变量 `selfie`。
>  **清理**：销毁 `temp_A`，销毁 `temp_B`。
> 
> **结果**：产生了一次创建，两次拷贝/移动，两次销毁。效率很低！
> 
> ##### 有了 RVO 之后 
> 编译器非常聪明，看穿了代码的意图：“既然你最后是要把结果放到 `selfie` 这个变量里，那我干脆直接在 `selfie` 的内存地址上把对象造出来不就行了？”
> 
> 1.  **直接构造**：`takePhoto()` 函数直接在 `selfie` 预留的内存地址上构造对象。
> 2.  **结束**：没有中间性能损耗。
> 
> **结果**：只有一次构造。**零拷贝，零移动，零临时对象销毁。**
> 
> **注**：在 **C++17** 标准中，这种优化已经变成了**强制标准**（Copy Elision），编译器必须这么做，不再是可选的优化了。

---

## Move Semantics

> What if we could reuse the memory instead?

不做复制，而是将原来需要拷贝的对象的资源的指针挪走

![2025Fall-14-MoveSemantics, 页面 36](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=36)

> But… is it always safe to do this? (Move)

Is it always safe to move objects? Assume `get_pixel` accesses data

![2025Fall-14-MoveSemantics, 页面 43](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=43)

But... How does the compiler know whether to move or copy?
```cpp
Photo selfie = pic;
// make COPIES of persistent objects (e.g. variables)
// that might get used in the future

Photo selfie = takePhoto();
// MOVE temporary objects (e.g return values)
// since we no longer need to use them
```
## 左右值


**左值 (Lvalue - Locator value)**：可以放在赋值操作符 = **左边**的表达式。它代表一个**有名字、有固定内存地址**的对象，可以被反复使用。

```cpp
int x = 10;       // x 是一个左值
std::string s = "hello"; // s 是一个左值
int* p = &x;      // *p 是一个左值
```

**右值 (Rvalue - Read value)**：只能放在赋值操作符 = **右边**的表达式。它通常代表一个**临时的、没有名字**的值，一般来说语句结束后就会被销毁。

```cpp
int y = 10;           // 10 是一个右值
int z = x + y;        // (x + y) 的计算结果是一个右值
std::string str = "world"; // "world" 是一个右值
std::string getName() { return "Bjarne"; }
std::string name = getName(); // getName() 的返回值是一个右值
```

> lvalues and rvalues generalize the idea of "temporariness" in C++

![2025Fall-14-MoveSemantics, 页面 50](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=50)

小测验：

![2025Fall-14-MoveSemantics, 页面 52](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=52)

- An lvalue's lifetime is until  **the end of scope **
- An rvalue's lifetime is until  **the end of line ** 
- An lvalue is persistent 
- An rvalue is temporary

![2025Fall-03-InitializationAndReferences, 页面 72](files/slides/CS106L/2025Fall-03-InitializationAndReferences.pdf#page=72)


> If we have an lvalue, how can we avoid copying its memory?

```cpp
void uploadToInsta(Photo pic); 
int main() { 
	Photo selfie = takePhoto(); // selfie is lvalue 
	uploadToInsta(selfie); // ❌ Unnecessary copy is made here 
}

void uploadToInsta(Photo& pic); 
int main() { 
	Photo selfie = takePhoto(); // selfie is lvalue 
	uploadToInsta(selfie); // ✅ No copy is made here
}
```

> But... How can we avoid copying rvalues?

What happens if we try to pass by reference?
```cpp
void uploadToInsta(Photo& pic); 
int main() { 
	uploadToInsta(takePhoto()); // Does this work?
								// ❌ candidate function not viable: expects LVALUE as 1st argument
}
```


> Key Idea: Overloading `&` and `&&` parameters distinguish lvalue and rvalue references

Compiler decides which version of upload to call depending on whether argument is lvalue or rvalue!

![2025Fall-14-MoveSemantics, 页面 60](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=60)

![2025Fall-14-MoveSemantics, 页面 61](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=61)

### 移动语义

移动语义是C++11及以后版本性能提升的关键特性之一，它使得像 std::vector, std::string, std::unique_ptr 等资源管理类能够被高效地按值返回和传递。

C++11为了解决类似于拷贝开销的问题，引入了两个新东西：

1. **右值引用 (Rvalue Reference)**：用 && 表示，它**只能绑定到右值**。这让我们可以专门为右值编写特定版本的函数。
2. **移动构造函数 (Move Constructor)** 和 **移动赋值运算符 (Move Assignment Operator)**。

 下图为拷贝的SMF与移动语义的SMF的对比：
 
![2025Fall-14-MoveSemantics, 页面 70](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=70)


![2025Fall-14-MoveSemantics, 页面 70](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=72)

## `std::move`

![2025Fall-14-MoveSemantics, 页面 79](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=79)


> [!question] std::move
> 有时候，我们有一个左值，但我们确定不再需要它了，想把它当成右值来触发移动语义。这时就需要 std::move
> ```
> MyString a("hello");
>
> // 强制把 a 当成右值，调用移动构造函数
> //a 的资源已经被 b 移走，a 内部的指针是 nullptr，之后不能再使用a。
> MyString b = std::move(a);
> ```
>std::move 本身不做任何移动操作，它只是一个**类型转换**，它告诉编译器：“请把这个左值当作右值来处理吧”。

> Usually, we let the compiler decide between & and &&
> Is that always the most efficient choice?
> E.g. what if we know that an lvalue will never be used again?

![2025Fall-14-MoveSemantics, 页面 76](files/slides/CS106L/2025Fall-14-MoveSemantics.pdf#page=76)


> [!NOTE] 第 3 行的问题所在 (The Problem)
> 复制
> 
> `myPhotos[i] = myPhotos[i - 1]; // Shuffle elements down`
> 
> 这行代码是把前一个位置 `i-1` 的照片，赋值给当前位置 `i`。
> 
> - **编译器的视角**：`myPhotos[i-1]` 是一个有名字的变量（左值）。编译器为了安全，默认执行**拷贝赋值 (Copy Assignment)**。
> - **为什么说是“浪费”？**
>     - PPT 的文字写道：_"even though the original value is never used again"_（尽管原来的值再也不会被使用了）。
>     - 既然 `myPhotos[i-1]` 马上就要被覆盖了，我们根本不需要保留它的副本！我们只需要把它move到下一个格子里去。
> - 所以，改为`myPhotos[i] = std::move(myPhotos[i - 1]);` 即可提高效率




[^1]: https://github.com/shulva/mcpp-standard/blob/dev/dslings/cpp11/05-move-semantics-2.cpp
