# 编译期计算

> [!quote]
> https://en.cppreference.com/w/cpp/language/constexpr
> https://en.cppreference.com/w/cpp/named_req/LiteralType.html

### constexpr[^1]

constexpr 是 C++11 引入的一个非常强大的关键字，它将 C++ 的计算能力从**运行时**扩展到了**编译时**，constexpr 赋予了 C++ 在**编译时**执行计算的能力。

简单来说，constexpr 告诉编译器：“**这个表达式或函数，如果可能的话，请在编译期间就把它计算出来**”

constexpr 可以用来修饰两种东西：**变量**和**函数**。

---
###### constexpr变量

一个被 constexpr 修饰的变量，它的值必须在**编译时**就能确定下来。它比 const 更严格。

**const**：表示一个变量是“只读的”（read-only）。它的值**可能**在编译时确定，也**可能**在运行时才确定。
**constexpr**：表示一个变量是“编译时常量”。它的值**必须**在编译时就确定。

---
###### constexpr函数

constexpr要求函数计算的最终结果必须能在编译时产生
同时，函数不能有 I/O 操作、不能修改全局变量、不能调用非 constexpr 函数等会产生"side effect"的行为

 **如果用编译时常量去调用它**，它就会在**编译时**执行。
 **如果用运行时变量去调用它**，它就会像普通函数一样，在**运行时**执行。

```cpp
constexpr long long fibonacci(int n) { 
	if (n <= 1) { 
	return n; 
	} 
	return fibonacci(n - 1) + fibonacci(n - 2); 
}

constexpr long long fib_10 = fibonacci(10); //编译时计算
int x; cin>> x; long long fib_x = fibonacci(x);//运行时计算
```

---

> [!question] 为什么使用constexpr?[^3]
> 我个人认为主要是以下几点：
> - 如果初始化在编译时完成，那么在多线程系统中，该对象就**不可能存在数据竞争**。  
> - 有时候，**在编译时求值一次**，比在运行时求值一百万次能带来显著的**性能提升**。

### Literal Types

A class with a **constexpr** constructor is called a literal type.[^4]
(说实话，不太好懂)

如果一个对象要在编译时存在，编译器必须完全理解如何构造它、它占用多少内存，以及如何销毁它，而不需要执行任何运行时代码。
满足这些要求的类型，就被称为 Literal Type。

只有 Literal Type 的对象才能被声明为 constexpr

以下类型是**字面量类型**：
1. 标量类型 (Scalar types) 
2. 引用类型 (Reference types)
3. 字面量类型的数组  (an array of Literal Type)
4. 一个**可能带有 cv 限定符 (const/volatile) 的类类型**，详情请见[cppreference](https://en.cppreference.com/w/cpp/named_req/LiteralType.html)


[^1]: https://github.com/shulva/mcpp-standard/blob/dev/dslings/cpp11/07-constexpr-1.cpp
[^3]: [The C++ Programming Language](../../../../../files/books/Programming%20Language/The%20C++%20Programming%20Language%20[4th%20Edition]%20-%20Bjarne%20Stroustrup.pdf#page=277)
[^4]: [The C++ Programming Language](../../../../../files/books/Programming%20Language/The%20C++%20Programming%20Language%20[4th%20Edition]%20-%20Bjarne%20Stroustrup.pdf#page=279)
