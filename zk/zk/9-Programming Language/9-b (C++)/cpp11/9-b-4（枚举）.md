# 枚举 enum 

> [!quote]
> https://en.cppreference.com/w/cpp/language/enum

### enum与enum class[^1]

在所有新的 C++ 代码中，请始终优先使用enum class。

#### 作用域

**enum**：
**枚举成员被暴露在外部作用域中**，就像全局变量一样，这很容易导致命名冲突。

**enum class**：
**枚举成员被限制在枚举自身的作用域内**，访问时必须使用 枚举名::成员 的形式。

```cpp
enum Color { RED, GREEN, BLUE };
enum Feeling { HAPPY, SAD, RED }; // 编译错误！RED 重定义了

Color myColor = RED; //可以直接访问 RED

enum class Color { RED, GREEN, BLUE };
enum class Feeling { HAPPY, SAD, RED }; 

// Color c = RED; // 编译错误！RED 不在当前作用域
Color myColor = Color::RED; // 正确的访问方式
Feeling myFeeling = Feeling::RED; // 正确与 Color::RED 不冲突
```

#### 类型安全

**enum**：
**类型较弱，可以隐式地转换为整数类型** (int, char 等)。

**enum class**：
**类型非常强，不能隐式地转换为整数类型**。
如果需要转换，必须使用 static_cast 进行显式转换。

```cpp
enum Color { RED, GREEN, BLUE }; // RED=0, GREEN=1, BLUE=2
int colorValue = GREEN; //隐式转换为 int，colorValue 的值为 1

enum class Fruit {Orange , Waterlemon};
//int fruit = Fruit::Orange; 编译错误！不能隐式转换
int fruit = static_cast<int>(Fruit::Orange);
```

#### 自定义底层类型

**enum**：
底层类型由编译器根据枚举值的范围来决定，通常是 int，但也可能是 unsigned int, char 等。**开发者无法直接控制**。

**enum class**：
**可以（也推荐）显式地指定底层类型**。默认是 int。
这使得枚举的大小和表示是可预测和可控的，对于需要进行内存布局控制或与硬件交互的场景非常重要。

```cpp
enum class StatusCode : std::uint8_t { 
OK = 0, 
NotFound = 1, 
ServerError = 2 
};

//任何一个 StatusCode 类型的变量，它在内存中占用的空间就和 std::uint8_t 类型的变量完全一样。

static_assert(sizeof(StatusCode) == 1); //Ture
```


> [!question] 什么是static_assert？
> **static_assert 是一个在“编译时”进行断言（Assertion）的工具**
>如果 static_assert 的条件为 false，**程序将无法通过编译**，
>
> |   |   |   |
>|---|---|---|
>|特性|**static_assert (编译时断言)**|assert (运行时断言)|
>|**检查时间**|**编译期间**|**程序运行期间**|
>|**检查内容**|必须是**编译时常量**表达式。如类型大小、模板参数、constexpr函数结果等。|可以是任何运行时才能确定的布尔表达式。如变量的值、函数返回值等。|
>|**失败后果**|**编译失败**。代码根本无法生成。|**程序终止** (通常在Debug模式下)。在Release模式下通常被禁用。|
>|**主要目的**|保证代码的**静态属性**和**设计约束**是正确的。防止不满足特定条件的代码被编译。|捕捉程序的**逻辑错误**和**非法状态**。用于调试。|
>
>

[^1]: https://github.com/shulva/mcpp-standard/blob/dev/dslings/cpp11/06-scoped-enums-1.cpp
